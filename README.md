# notes
这里是我最近阅读的关于JS经典书籍的笔记，大部分是自己的理解，还有一些是别人的理解，拿到一起，方便阅读，如有侵权，请告知我，我立即删除！

## 1. 你不知道的JavaScript 上卷

资料文献：http://www.cnblogs.com/wangfupeng1988/p/3977924.html          https://www.jianshu.com/p/efe38b392f53

### chapter 1 作用域

程序能够存储变量的值，并在之后对这个值进行访问修改，那么问题来了，这些变量存储在哪里，如何在需要的时候找到他们，我们需要制定一套规则来存储

变量，这套规则就是作用域。

#### 1.1 编译原理

JS是解释执行语言，但事实上是一门编译语言。

传统的编译语言有三个步骤：

1.分词/词法分析

这个过程将由字符组成的字符串分解成对编程语言来说有意义的代码块，称为词法单元

如 将 `var a = 2`分解成`var 、a 、 = 、 2 、 ;` 空格是否有效取决于他是否有意义

2. 解析/语法分析

这个过程是将词法单元流转换成由元素逐级嵌套所组成的程序语法结构的树（AST）

3. 代码生成

将AST转换成可执行代码的过程。

简单来说，就是将`var a = 2`转换成机器指令，用来创建一个叫做a的变量（包括分配内存），并将一个值存在变量a中

编译器对`var a = 2`进行如下处理

1. 首先询问在同一作用域集合下是否已经存在一个该名称的变量，如果是，则忽略该声明，继续进行编译，否则声明一个新的变量a

2. 引擎运行时首先会询问作用域，在当前作用域下是否存在这么一个变量a，如果是，引擎就会使用这个变量，否则继续查找该变量

3. 如果找到了，就将2赋值给他，否则引擎将会抛出一个异常

引擎会为变量a进行LHS查找，另一个查找叫做RHS。即当变量出现在左侧时进行LHS查询（找到赋值操作的目标是谁，从而可以对其赋值），右侧时进行RHS查询（找到赋值操作的源头，即取值操作）

那么，`console.log(a)`就是一个RHS引用，而`a = 2`则是一个LHS引用

#### 1.3 作用域的嵌套

当一个块或函数嵌套在另一个块或函数中时，就产生了作用域的嵌套。在当前作用域中无法找到某个变量时，引擎就会去外层嵌套的作用域进行查找，直到找到该变量，一直到全局作用域为止！

不成功的LHS引用会导致自动隐式的创建一个全局变量（非严格模式下），而不成功的RHS引用会导致抛出ReferenceError异常。

### chapter 2 词法作用域

#### 2.1 词法阶段

词法作用域在函数定义时就已经确定了，而不是函数调用时确定！！！

作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套作用域中，可以定义同名的标识符，称为“遮蔽效应”

作用域查找始终从运行时所处的最内部作用域开始，逐级向外层查找，直到遇到第一个匹配的标识符为止。

在这里，全局变量会自动成为全局对象（在浏览器环境下是window）的属性，因此，我们可以得出下面的结果：

```

a = 10;

console.log(window.a === 10) // true

```

#### 2.2 欺骗词法

前面我们说到，词法作用域往往是在函数定义时决定，那么我们如何才能在运行时来修改词法作用域呢？

注意，修改词法作用域会导致性能下降，我们并不推荐这么做！eval和with

### chapter 3 函数作用域和块级作用域

在JS中，只有函数才能创建作用域，我们无法在一个函数的外部去访问其内部变量的值。

通常，我们都是先声明一个函数，再向里面添加代码。我们也可以反过来，在所写的代码中任挑选一段，用函数声明进行包装，实际上就是将他隐藏起来了。

例如：

```

var a = 2;

function foo() {            <--- 添加这一行

    var a = 3;

    console.log(a); // 3

}                           <--- 添加这一行

foo();                      <--- 添加这一行

console.log(a); // 2

```

这样做会导致全局作用域里多了一个foo，我们还可以这样：

```

var a = 2;

(function foo() {            <--- 添加这一行

    var a = 3;

    console.log(a); // 3

})()                         <--- 添加这一行

console.log(a); // 2

```

在这里，foo变成了一个函数表达式，函数声明和函数表达式的区别是前者的foo被绑定在所在作用域中（全局环境），而后者(function foo(){...})只能在...处被访问，外部作用域则不行。

#### 3.2 匿名函数

通常，我们可以在回调函数中见到匿名函数，如：

```

setTimeout(function (){

    console.log('this is a function')

}, 1000)

```

#### 3.3 立即执行函数

```

var a = 2;

(function foo(){

    var a = 3;

    console.log(a); // 3

})()

console.log(a); // 2

```

#### 3.4 块级作用域

es3中的try/catch的catch会创建一个块级作用域，但是个别浏览器会报错，因此有的开发者会将catch的参数命名为err1，err2...

es6以前没有块级作用域的概念，直到es6中，我们可以用{}来创建一个块级作用域。

### chapter 4 提升

JavaScript看到 var a = 2 时，会将其看成两个部分，var a, a = 2，第一个声明是在编译阶段执行，第二个赋值声明是留在原地等待执行阶段

函数声明会被提升，而函数表达式不会

函数声明和变量声明都会被提升，但是函数优先，然后才是变量

```

foo();                  // 若没有第三个，则会输出1，否则输出3

function foo() {
    console.log(1);
}

var foo = function() {
    console.log(2);
}

function foo() {
    console.log(3);
}

```

### chapter 5 作用域和闭包

